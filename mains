mod sat;
mod prover;
mod fol;
use fol::ast::Cnf;
use fol::ast::Grounded;
use fol::parser;
use fol::ast;


fn test_parse() {
    println!("Parser:");
    println!("{}", parser::parse("P(x)").unwrap());
    println!("{}", parser::parse("P(x, y)").unwrap());
    println!("{}", parser::parse("P(x) or not P(x)").unwrap());
    println!("{}", parser::parse("exists y . Q(y)").unwrap());
    println!("{}", parser::parse("forall x . (exists y . (P(x) => Q(y)))").unwrap());
    println!("{}", parser::parse("forall x . (not (P(x) or Q(x)))").unwrap());
    println!("{}", parser::parse("(P(x) and Q(y)) => R(z)").unwrap());
    println!("{}", parser::parse("forall x. P(x) => (Q(x) => P(x))").unwrap());
    println!("{}", parser::parse("exists x. (P(x) => forall y. P(y))").unwrap());
    println!("{}", parser::parse("exists x. (P(x) => forall y. P(y))").unwrap());
    println!("{}", parser::parse("exists x. (P(x) <=> Q(x))").unwrap());
    println!("{}", parser::parse("forall x. (P(x) <=> Q(x))").unwrap());
    println!("");
}


fn test_substitution() {
    fn substitute(input: &str, from: &str, to: &str) {
        let mut t = parser::parse(input).unwrap();
        print!("\x1b[32;1m{}\x1b[0m[{}/{}] -> ", t, from, to);
        let from_var = ast::Var::from_string(from.to_string());
        let to_var = ast::Var::from_string(to.to_string());
        t.substitute(from_var, to_var.to_term());
        println!("{}", t);
    }
    println!("Substitution:");
    substitute("P(x)", "x", "y");
    substitute("P(x)", "x", "y");
    substitute("forall a. P(f(a))", "x", "y");
    substitute("forall x. P(x) and P(y)", "y", "x");
    substitute("exists x. P(x) and P(y)", "y", "x");
    substitute("forall a. P(a) and (forall b. P(b))", "x", "y");
    substitute("forall x. (P(x) => Q(x))", "x", "y");
    substitute("forall x. (exists y. (P(x) => Q(y)))", "x", "y");
    substitute("forall x. P(x) and forall y. Q(y)", "x", "y");
    substitute("exists x. P(x) or exists y. Q(y)", "x", "y");
    substitute("forall x. P(x) => exists y. Q(y)", "x", "y");
    substitute("not (forall x. P(x))", "x", "y");
    substitute("not (exists x. P(x))", "x", "y");
    substitute("not (forall x. exists y. (P(x) and Q(y)))", "x", "y");
    substitute("forall x. (P(x) => forall y. (Q(y) => exists z. R(z)))", "x", "y");
    substitute("forall x. forall y. forall z. P(f(x)) and P(y) and P(z)", "x", "y");
    substitute("forall x. exists y. forall z. exists w. P(x,y,z,w)", "x", "y");
    println!("");
}


fn test_pipeline() {
    fn pipeline(input: &str, satisfiable: bool) {
        let t = parser::parse(input).unwrap();
        println!("\x1b[32;1m{}\x1b[0m", t);
        let t = t.to_nnf();
        println!("  +-nnf---> {}", t);
        let t = t.to_pnf();
        println!("  +-pnf---> {}", t);
        let t = t.skolemize();
        println!("  +-skole-> {}", t);
        let t = t.ground();
        println!("  +-ground-> {}", t);
        let t = t.to_cnf().cast::<Grounded>();
        println!("  +-cnf-> {}", t);
        let cnfset = sat::set::CNFSet::from_formula(t.cast::<Cnf>());
        println!("  +-cnfset-> {:?}", cnfset);
        let sat = sat::dp::satisfiable_dp(cnfset);
        println!("  +-sat---> {:?}", sat);
        if sat == satisfiable {
            println!("\x1b[32;1mOk\x1b[0m");
        } else {
            println!("\x1b[31;1mErr\x1b[0m");
        }
        println!("");
    }

    println!("CNFs:");
    pipeline("P(x)", true);
    pipeline("(P(x) or not Q(x)) and (P(x) or not Q(x) or R(x)) and (not R(x))", true);
    pipeline("P(x) or Q(x)", true); // Either P(x) or Q(x) must hold.
    pipeline("(P(x) or Q(x)) and (not P(x) or R(x))", true); // Satisfiable if Q(x) or R(x) is true.
    pipeline("(P(x) or Q(x)) and (not Q(x) or R(x)) and (not R(x) or S(x))", true); // Can be satisfied with appropriate assignment.
    pipeline("(P(x) or Q(x)) and (P(x) or not Q(x))", true); // Satisfiable for any value of P(x).
    pipeline("(P(x)) and (Q(x)) and (R(x))", true); // Satisfiable if all are true.
    pipeline("P(x) and not P(x)", false); // Direct contradiction.
    pipeline("(P(x) or Q(x)) and (not P(x)) and (not Q(x))", false); // Forces both literals in disjunction to be false.
    pipeline("(P(x)) and (not P(x) or Q(x)) and (not Q(x))", false); // Forces P(x) and not P(x).
    pipeline("(P(x) or Q(x)) and (not P(x) or Q(x)) and (P(x) or not Q(x)) and (not P(x) or not Q(x))", false); // Pigeonhole-type contradiction.
    pipeline("(P(x) or Q(x)) and (not Q(x)) and (not P(x))", false); // All literals negated, contradicts first clause.
    pipeline("(P(x) or not P(x)) and (not P(a) or P(b)) and P(a)", false);
    pipeline("forall a. P(f(a))", true);
    println!("Push negations:");
    pipeline("forall a. not (P(a) and P(b))", true);
    pipeline("forall a. not (P(a) or P(b))", true);
    pipeline("not (forall x. P(x))", true);
    pipeline("not (exists x. P(x))", true);
    pipeline("not (forall x. exists y. (P(x) and Q(y)))", true);
    println!("Eliminate arrows:");
    pipeline("forall a. forall b. P(a) <=> P(b)", true);
    pipeline("forall x. P(x) => Q(x)", true);
    println!("Skolemization:");
    pipeline("forall x. exists y. forall z. exists w. P(x,y,z,w)", true);
    pipeline("exists x. (forall y. (P(x, y) and Q(x)))", true);
    pipeline("forall x. exists y. exists z. (P(x) and Q(y) and R(z))", true);
    pipeline("forall x. (P(x) <=> forall y. Q(y) and exists z. R(z))", true);
    println!("Contradiction:");
    pipeline("forall a. P(a) and not P(a)", false);
    println!("Misc:");
    pipeline("forall a. P(a) and (forall b. P(b))", true);
    pipeline("forall x. (exists y. (P(x) => Q(y)))", true);
    pipeline("forall x. P(x) and forall y. Q(y)", true);
    pipeline("exists x. P(x) or exists y. Q(y)", true);
    pipeline("forall x. P(x) => exists y. Q(y)", true);
    pipeline("forall x. (P(x) => forall y. (Q(y) => exists z. R(z)))", true);
    pipeline("forall x. forall y. forall z. P(f(x)) and P(y) and P(z)", true);
    pipeline("exists x. exists y. P(x, y)", true);
    pipeline("exists x. forall y. P(x) and Q(y)", true);
    pipeline("forall x. exists y. P(x, y) and Q(y)", true);
    pipeline("exists x. forall y. exists z. P(x, y, z)", true);
    pipeline("forall x. exists y. (P(x) => Q(y))", true);
    pipeline("forall x. (exists y. (P(x) => Q(y))) and R(x)", true);
    pipeline("exists x. exists y. forall z. P(x, y, z) and Q(x, y)", true);
    pipeline("forall x. (exists y. (P(x) => exists z. Q(y, z)))", true);
    pipeline("not (exists x. exists y. P(x, y))", true);
    pipeline("forall x. (exists y. (P(x, y) => Q(y)))", true);
    pipeline("exists x. forall y. exists z. (P(x, y) and Q(z))", true);
    pipeline("forall x. (exists y. (P(x) and Q(y))) and R(x)", true);
    pipeline("forall x. (P(x) and exists y. Q(x, y)) <=> not (P(x))", true);
    println!("");
}


fn main() {
    test_parse();
    test_substitution();
    test_pipeline();
}
